# Automatic Function Chain Generation
## Claude's Blueprint for Consistent, Maintainable FP Across Stacks

This guide shows how Claude automatically generates composed function chains with error checking, using identical patterns across Python and TypeScript. **Developers don't need to understand monads** - they just follow the patterns.

---

## Core Principle: The Universal Pipeline Pattern

**Every operation follows the same 3-step pattern in BOTH languages:**

```
Input → Validate → Transform → Save → Output
   ↓        ↓          ↓         ↓       ↓
Result   Result    Result    Result  Result
```

If any step fails, the chain stops. If all succeed, you get the final result.

---

## Table of Contents

1. [The Universal Pattern](#the-universal-pattern)
2. [Automatic Chain Generation](#automatic-chain-generation)
3. [Pattern Library](#pattern-library)
4. [Maintenance Guide](#maintenance-guide)
5. [Real-World Examples](#real-world-examples)

---

## The Universal Pattern

### Mental Model (Same for Both Languages)

Think of it like a factory assembly line:
1. **Each station does one thing**
2. **If a station fails, the whole line stops**
3. **If all succeed, you get the final product**

```
Raw Material → [Check Quality] → [Process] → [Package] → Final Product
     ↓              ✓ or ✗         ✓ or ✗      ✓ or ✗         ↓
  Success          Success        Success     Success     Success
```

### The Pattern in Code

**Python:**
```python
result = (
    step1(input)           # Returns Success(value) or Failure(error)
    .bind(step2)           # Only runs if step1 succeeded
    .bind(step3)           # Only runs if step2 succeeded
    .map(step4)            # Transform the value if all succeeded
)
```

**TypeScript:**
```typescript
const result = pipe(
  step1(input),            // Returns Right(value) or Left(error)
  TE.flatMap(step2),       // Only runs if step1 succeeded
  TE.flatMap(step3),       // Only runs if step2 succeeded
  TE.map(step4)            // Transform the value if all succeeded
)
```

**They're identical in structure!**

---

## Automatic Chain Generation

### When User Says: "Fetch user from database, validate age, update profile, and return result"

### Claude Automatically Generates (Python):

```python
from dataclasses import dataclass
from typing import Literal
from returns.result import Result, Success, Failure
from returns.pipeline import pipe

# 1. TYPES (Auto-generated)
@dataclass(frozen=True)
class User:
    id: str
    name: str
    age: int
    email: str

@dataclass(frozen=True)
class UserError:
    _tag: Literal['NotFound', 'ValidationError', 'DatabaseError']
    message: str

# 2. INDIVIDUAL STEPS (Auto-generated)
def fetch_user(user_id: str) -> Result[User, UserError]:
    """Step 1: Fetch from database"""
    try:
        # Database call here
        user = db.get_user(user_id)
        if not user:
            return Failure(UserError(_tag='NotFound', message=f'User {user_id} not found'))
        return Success(user)
    except Exception as e:
        return Failure(UserError(_tag='DatabaseError', message=str(e)))

def validate_age(user: User) -> Result[User, UserError]:
    """Step 2: Validate age requirement"""
    if user.age < 18:
        return Failure(UserError(
            _tag='ValidationError',
            message=f'User must be 18+, got {user.age}'
        ))
    return Success(user)

def update_profile(user: User) -> Result[User, UserError]:
    """Step 3: Update profile"""
    try:
        updated = db.update_user(user.id, {'verified': True})
        return Success(updated)
    except Exception as e:
        return Failure(UserError(_tag='DatabaseError', message=str(e)))

def format_response(user: User) -> dict:
    """Step 4: Format for output (can't fail)"""
    return {
        'id': user.id,
        'name': user.name,
        'email': user.email
    }

# 3. COMPOSED CHAIN (Auto-generated)
def process_user(user_id: str) -> Result[dict, UserError]:
    """
    Complete pipeline - auto-generated by Claude.
    
    Steps:
    1. Fetch user from database
    2. Validate age is 18+
    3. Update profile to verified
    4. Format response
    
    Returns:
        Success(dict): User data if all steps succeed
        Failure(UserError): First error encountered
    """
    return (
        fetch_user(user_id)
        .bind(validate_age)
        .bind(update_profile)
        .map(format_response)
    )

# 4. USAGE (Auto-generated)
result = process_user('user-123')

match result:
    case Success(data):
        print(f"Success: {data}")
    case Failure(error):
        print(f"Error ({error._tag}): {error.message}")
```

### Claude Automatically Generates (TypeScript):

```typescript
import * as TE from 'fp-ts/TaskEither'
import { pipe } from 'fp-ts/function'

// 1. TYPES (Auto-generated)
interface User {
  readonly id: string
  readonly name: string
  readonly age: number
  readonly email: string
}

type UserError = 
  | { readonly _tag: 'NotFound'; readonly message: string }
  | { readonly _tag: 'ValidationError'; readonly message: string }
  | { readonly _tag: 'DatabaseError'; readonly message: string }

// 2. INDIVIDUAL STEPS (Auto-generated)
const fetchUser = (userId: string): TE.TaskEither<UserError, User> =>
  TE.tryCatch(
    async () => {
      const user = await db.getUser(userId)
      if (!user) {
        throw { _tag: 'NotFound', message: `User ${userId} not found` }
      }
      return user
    },
    (error): UserError => {
      if (typeof error === 'object' && error !== null && '_tag' in error) {
        return error as UserError
      }
      return { _tag: 'DatabaseError', message: String(error) }
    }
  )

const validateAge = (user: User): TE.TaskEither<UserError, User> =>
  user.age >= 18
    ? TE.right(user)
    : TE.left({
        _tag: 'ValidationError',
        message: `User must be 18+, got ${user.age}`
      })

const updateProfile = (user: User): TE.TaskEither<UserError, User> =>
  TE.tryCatch(
    async () => {
      const updated = await db.updateUser(user.id, { verified: true })
      return updated
    },
    (error): UserError => ({
      _tag: 'DatabaseError',
      message: String(error)
    })
  )

const formatResponse = (user: User) => ({
  id: user.id,
  name: user.name,
  email: user.email
})

// 3. COMPOSED CHAIN (Auto-generated)
const processUser = (userId: string): TE.TaskEither<UserError, object> =>
  pipe(
    fetchUser(userId),
    TE.flatMap(validateAge),
    TE.flatMap(updateProfile),
    TE.map(formatResponse)
  )

// 4. USAGE (Auto-generated)
const result = await processUser('user-123')()

if (result._tag === 'Right') {
  console.log('Success:', result.right)
} else {
  console.log(`Error (${result.left._tag}):`, result.left.message)
}
```

### Key Observation

**The structure is IDENTICAL:**
- Same 4 steps
- Same error handling
- Same composition pattern
- Same mental model

**Developers just need to know:**
1. `.bind()` / `flatMap()` = "do this next if previous succeeded"
2. `.map()` = "transform the value"
3. Pattern match the result at the end

---

## Pattern Library

### Pattern 1: Fetch → Validate → Transform

**Use Case:** API endpoints, data processing

**Python Template:**
```python
def process_data(input_id: str) -> Result[Output, Error]:
    """Fetch, validate, transform pattern"""
    return (
        fetch_from_source(input_id)    # Get data
        .bind(validate_rules)           # Check it's valid
        .bind(transform_data)           # Process it
        .map(format_output)             # Format result
    )
```

**TypeScript Template:**
```typescript
const processData = (inputId: string): TE.TaskEither<Error, Output> =>
  pipe(
    fetchFromSource(inputId),          // Get data
    TE.flatMap(validateRules),         // Check it's valid
    TE.flatMap(transformData),         // Process it
    TE.map(formatOutput)               // Format result
  )
```

### Pattern 2: Load → Process → Save

**Use Case:** ETL, batch processing

**Python Template:**
```python
def etl_pipeline(source: str) -> Result[Stats, Error]:
    """Load, process, save pattern"""
    return (
        load_data(source)               # Load from source
        .bind(clean_data)               # Clean it
        .bind(transform_data)           # Transform it
        .bind(save_to_destination)      # Save it
        .map(generate_stats)            # Return stats
    )
```

**TypeScript Template:**
```typescript
const etlPipeline = (source: string): TE.TaskEither<Error, Stats> =>
  pipe(
    loadData(source),                  // Load from source
    TE.flatMap(cleanData),             // Clean it
    TE.flatMap(transformData),         // Transform it
    TE.flatMap(saveToDestination),     // Save it
    TE.map(generateStats)              // Return stats
  )
```

### Pattern 3: Parallel Operations → Combine

**Use Case:** Multiple API calls, batch operations

**Python Template:**
```python
def fetch_user_data(user_id: str) -> Result[UserData, Error]:
    """Fetch multiple things in parallel"""
    from returns.result import Success
    
    # Fetch all pieces
    user_result = fetch_user(user_id)
    posts_result = fetch_posts(user_id)
    comments_result = fetch_comments(user_id)
    
    # Combine results
    return (
        Success({'user': None, 'posts': None, 'comments': None})
        .bind(lambda d: user_result.map(lambda u: {**d, 'user': u}))
        .bind(lambda d: posts_result.map(lambda p: {**d, 'posts': p}))
        .bind(lambda d: comments_result.map(lambda c: {**d, 'comments': c}))
    )
```

**TypeScript Template:**
```typescript
const fetchUserData = (userId: string): TE.TaskEither<Error, UserData> =>
  pipe(
    TE.Do,
    TE.apS('user', fetchUser(userId)),
    TE.apS('posts', fetchPosts(userId)),
    TE.apS('comments', fetchComments(userId))
  )
```

### Pattern 4: Conditional Branching

**Use Case:** Different logic based on data

**Python Template:**
```python
def process_order(order_id: str) -> Result[Receipt, Error]:
    """Branch based on order type"""
    return (
        fetch_order(order_id)
        .bind(lambda order: 
            process_digital_order(order) 
            if order.type == 'digital' 
            else process_physical_order(order)
        )
        .map(generate_receipt)
    )
```

**TypeScript Template:**
```typescript
const processOrder = (orderId: string): TE.TaskEither<Error, Receipt> =>
  pipe(
    fetchOrder(orderId),
    TE.flatMap(order =>
      order.type === 'digital'
        ? processDigitalOrder(order)
        : processPhysicalOrder(order)
    ),
    TE.map(generateReceipt)
  )
```

### Pattern 5: Collection Processing

**Use Case:** Process multiple items

**Python Template:**
```python
def process_users(user_ids: list[str]) -> Result[list[User], Error]:
    """Process collection of items"""
    results = [process_user(uid) for uid in user_ids]
    
    # Fail if any failed (all-or-nothing)
    collected = []
    for result in results:
        if isinstance(result, Failure):
            return result
        collected.append(result.unwrap())
    
    return Success(collected)
```

**TypeScript Template:**
```typescript
import * as A from 'fp-ts/Array'

const processUsers = (userIds: string[]): TE.TaskEither<Error, User[]> =>
  A.traverse(TE.ApplicativePar)(processUser)(userIds)
```

---

## Maintenance Guide

### For Developers Who Don't Know FP

**You don't need to understand monads. Just follow these rules:**

### Rule 1: Each Function Does One Thing

```python
# ✅ GOOD - does one thing
def validate_email(user: User) -> Result[User, Error]:
    if '@' not in user.email:
        return Failure(Error('Invalid email'))
    return Success(user)

# ❌ BAD - does multiple things
def validate_and_save_user(user: User) -> Result[User, Error]:
    if '@' not in user.email:
        return Failure(Error('Invalid email'))
    db.save(user)  # Don't mix validation and IO
    return Success(user)
```

### Rule 2: Use `.bind()` for Operations That Can Fail

```python
# Operations that can fail use .bind()
result = (
    fetch_user(id)           # Can fail
    .bind(validate_user)     # Can fail
    .bind(update_database)   # Can fail
    .map(format_response)    # Can't fail (just transforms)
)
```

**Think of `.bind()` as "try this next"**

### Rule 3: Use `.map()` for Safe Transformations

```python
# Safe transformations use .map()
result = (
    fetch_user(id)
    .map(lambda user: user.name.upper())      # Just transforms
    .map(lambda name: {'display_name': name}) # Just formats
)
```

**Think of `.map()` as "change the value"**

### Rule 4: Always Return `Success` or `Failure`

```python
def my_operation(data: Data) -> Result[Output, Error]:
    if something_wrong:
        return Failure(Error('What went wrong'))
    
    # do work
    
    return Success(result)
```

### Rule 5: Pattern Match at the End

**Python:**
```python
match result:
    case Success(data):
        # do something with data
    case Failure(error):
        # handle error
```

**TypeScript:**
```typescript
if (result._tag === 'Right') {
  // do something with result.right
} else {
  // handle result.left
}
```

### Adding a New Step to a Chain

**Need to add email validation?**

1. **Write the function:**
```python
def validate_email(user: User) -> Result[User, Error]:
    if '@' not in user.email:
        return Failure(Error('Invalid email'))
    return Success(user)
```

2. **Add to chain:**
```python
result = (
    fetch_user(id)
    .bind(validate_age)
    .bind(validate_email)  # ← Add here
    .bind(update_profile)
    .map(format_response)
)
```

Done! The chain handles everything else.

### Debugging a Chain

**Which step failed?**

```python
result = (
    fetch_user(id)
    .inspect(lambda u: print(f"Fetched: {u}"))        # Print if success
    .bind(validate_age)
    .inspect(lambda u: print(f"Validated: {u}"))      # Print if success
    .bind(update_profile)
    .inspect(lambda u: print(f"Updated: {u}"))        # Print if success
)

# Only prints messages up to where it failed
```

---

## Real-World Examples

### Example 1: API Endpoint (Next.js)

**User says:** "Create an API endpoint to update user settings"

**Claude generates:**

```typescript
// app/api/users/[id]/settings/route.ts
import * as TE from 'fp-ts/TaskEither'
import { pipe } from 'fp-ts/function'
import { NextRequest, NextResponse } from 'next/server'

// Types (auto-generated)
interface Settings {
  readonly theme: 'light' | 'dark'
  readonly notifications: boolean
  readonly language: string
}

type ApiError = 
  | { readonly _tag: 'ValidationError'; readonly message: string }
  | { readonly _tag: 'NotFound' }
  | { readonly _tag: 'DatabaseError'; readonly message: string }

// Steps (auto-generated)
const parseBody = (request: NextRequest): TE.TaskEither<ApiError, Settings> =>
  TE.tryCatch(
    async () => {
      const body = await request.json()
      return body as Settings
    },
    (): ApiError => ({
      _tag: 'ValidationError',
      message: 'Invalid request body'
    })
  )

const validateSettings = (settings: Settings): TE.TaskEither<ApiError, Settings> => {
  const validThemes = ['light', 'dark']
  const validLanguages = ['en', 'es', 'fr']
  
  if (!validThemes.includes(settings.theme)) {
    return TE.left({
      _tag: 'ValidationError',
      message: 'Invalid theme'
    })
  }
  
  if (!validLanguages.includes(settings.language)) {
    return TE.left({
      _tag: 'ValidationError',
      message: 'Invalid language'
    })
  }
  
  return TE.right(settings)
}

const saveSettings = (
  userId: string,
  settings: Settings
): TE.TaskEither<ApiError, Settings> =>
  TE.tryCatch(
    async () => {
      const { error } = await supabase
        .from('user_settings')
        .update(settings)
        .eq('user_id', userId)
      
      if (error) throw error
      return settings
    },
    (error): ApiError => ({
      _tag: 'DatabaseError',
      message: String(error)
    })
  )

// Composed chain (auto-generated)
const updateUserSettings = (
  userId: string,
  request: NextRequest
): TE.TaskEither<ApiError, Settings> =>
  pipe(
    parseBody(request),
    TE.flatMap(validateSettings),
    TE.flatMap(settings => saveSettings(userId, settings))
  )

// Handler (auto-generated)
export async function PUT(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const result = await updateUserSettings(params.id, request)()
  
  if (result._tag === 'Right') {
    return NextResponse.json(result.right)
  }
  
  const error = result.left
  const status = error._tag === 'NotFound' ? 404
    : error._tag === 'ValidationError' ? 400
    : 500
  
  return NextResponse.json(
    { error: error._tag, message: error.message },
    { status }
  )
}
```

### Example 2: Data Processing (Python + Polars)

**User says:** "Load CSV, clean data, compute statistics, save to database"

**Claude generates:**

```python
from dataclasses import dataclass
from typing import Literal
from returns.result import Result, Success, Failure
from returns.pipeline import pipe
import polars as pl

# Types (auto-generated)
@dataclass(frozen=True)
class Statistics:
    mean: float
    median: float
    std_dev: float
    row_count: int

@dataclass(frozen=True)
class ProcessingError:
    _tag: Literal['LoadError', 'ValidationError', 'ComputeError', 'SaveError']
    message: str
    details: dict | None = None

# Steps (auto-generated)
def load_csv(path: str) -> Result[pl.DataFrame, ProcessingError]:
    """Step 1: Load CSV file"""
    try:
        df = pl.read_csv(path)
        return Success(df)
    except Exception as e:
        return Failure(ProcessingError(
            _tag='LoadError',
            message=str(e),
            details={'path': path}
        ))

def validate_columns(df: pl.DataFrame) -> Result[pl.DataFrame, ProcessingError]:
    """Step 2: Validate required columns exist"""
    required = ['value', 'timestamp', 'category']
    missing = [col for col in required if col not in df.columns]
    
    if missing:
        return Failure(ProcessingError(
            _tag='ValidationError',
            message=f'Missing columns: {missing}'
        ))
    
    return Success(df)

def clean_data(df: pl.DataFrame) -> Result[pl.DataFrame, ProcessingError]:
    """Step 3: Clean data"""
    try:
        cleaned = (
            df
            .filter(pl.col('value').is_not_null())
            .filter(pl.col('value') > 0)
            .with_columns(
                pl.col('timestamp').str.strptime(pl.Datetime, '%Y-%m-%d')
            )
        )
        return Success(cleaned)
    except Exception as e:
        return Failure(ProcessingError(
            _tag='ValidationError',
            message=f'Data cleaning failed: {str(e)}'
        ))

def compute_statistics(df: pl.DataFrame) -> Result[Statistics, ProcessingError]:
    """Step 4: Compute statistics"""
    try:
        stats = Statistics(
            mean=df['value'].mean(),
            median=df['value'].median(),
            std_dev=df['value'].std(),
            row_count=len(df)
        )
        return Success(stats)
    except Exception as e:
        return Failure(ProcessingError(
            _tag='ComputeError',
            message=str(e)
        ))

def save_to_database(stats: Statistics) -> Result[Statistics, ProcessingError]:
    """Step 5: Save to database"""
    try:
        db.save_statistics({
            'mean': stats.mean,
            'median': stats.median,
            'std_dev': stats.std_dev,
            'row_count': stats.row_count
        })
        return Success(stats)
    except Exception as e:
        return Failure(ProcessingError(
            _tag='SaveError',
            message=str(e)
        ))

# Composed chain (auto-generated)
def process_data_file(path: str) -> Result[Statistics, ProcessingError]:
    """
    Complete data processing pipeline.
    
    Steps:
    1. Load CSV file
    2. Validate required columns
    3. Clean data (remove nulls, filter invalid)
    4. Compute statistics
    5. Save to database
    
    Returns:
        Success(Statistics): Stats if all steps succeed
        Failure(ProcessingError): First error encountered
    """
    return (
        load_csv(path)
        .bind(validate_columns)
        .bind(clean_data)
        .bind(compute_statistics)
        .bind(save_to_database)
    )

# Usage (auto-generated)
result = process_data_file('data.csv')

match result:
    case Success(stats):
        print(f"Processed {stats.row_count} rows")
        print(f"Mean: {stats.mean:.2f}")
        print(f"Median: {stats.median:.2f}")
    case Failure(error):
        print(f"Error ({error._tag}): {error.message}")
        if error.details:
            print(f"Details: {error.details}")
```

### Example 3: MLX Training Pipeline

**User says:** "Create a training loop with validation and checkpointing"

**Claude generates:**

```python
from dataclasses import dataclass
from returns.result import Result, Success, Failure
import mlx.core as mx

# Types (auto-generated)
@dataclass(frozen=True)
class TrainConfig:
    batch_size: int
    learning_rate: float
    num_epochs: int
    checkpoint_dir: str

@dataclass(frozen=True)
class TrainingState:
    epoch: int
    step: int
    weights: mx.array
    loss: float
    val_loss: float | None = None

@dataclass(frozen=True)
class TrainingError:
    _tag: Literal['ConfigError', 'DataError', 'TrainingError', 'CheckpointError']
    message: str

# Steps (auto-generated)
def validate_config(config: TrainConfig) -> Result[TrainConfig, TrainingError]:
    """Step 1: Validate configuration"""
    errors = []
    
    if config.batch_size <= 0:
        errors.append('batch_size must be positive')
    if config.learning_rate <= 0:
        errors.append('learning_rate must be positive')
    if config.num_epochs <= 0:
        errors.append('num_epochs must be positive')
    
    if errors:
        return Failure(TrainingError(
            _tag='ConfigError',
            message='; '.join(errors)
        ))
    
    return Success(config)

def load_data(config: TrainConfig) -> Result[tuple[mx.array, mx.array], TrainingError]:
    """Step 2: Load training data"""
    try:
        train_x = mx.random.normal((1000, 784))
        train_y = mx.random.randint(0, 10, (1000,))
        return Success((train_x, train_y))
    except Exception as e:
        return Failure(TrainingError(
            _tag='DataError',
            message=str(e)
        ))

def initialize_model(data: tuple[mx.array, mx.array]) -> Result[mx.array, TrainingError]:
    """Step 3: Initialize model weights"""
    try:
        train_x, _ = data
        input_size = train_x.shape[1]
        weights = mx.random.normal((input_size, 10))
        return Success(weights)
    except Exception as e:
        return Failure(TrainingError(
            _tag='TrainingError',
            message=f'Model initialization failed: {str(e)}'
        ))

def train_model(
    config: TrainConfig,
    data: tuple[mx.array, mx.array],
    initial_weights: mx.array
) -> Result[TrainingState, TrainingError]:
    """Step 4: Train model"""
    try:
        train_x, train_y = data
        weights = initial_weights
        
        for epoch in range(config.num_epochs):
            # Training logic here
            loss = mx.random.normal(())  # Placeholder
            
        final_state = TrainingState(
            epoch=config.num_epochs,
            step=config.num_epochs * (len(train_x) // config.batch_size),
            weights=weights,
            loss=float(loss)
        )
        
        return Success(final_state)
    except Exception as e:
        return Failure(TrainingError(
            _tag='TrainingError',
            message=str(e)
        ))

def save_checkpoint(
    config: TrainConfig,
    state: TrainingState
) -> Result[TrainingState, TrainingError]:
    """Step 5: Save checkpoint"""
    try:
        checkpoint_path = f"{config.checkpoint_dir}/checkpoint_{state.epoch}.npz"
        mx.save(checkpoint_path, {'weights': state.weights})
        return Success(state)
    except Exception as e:
        return Failure(TrainingError(
            _tag='CheckpointError',
            message=str(e)
        ))

# Composed chain (auto-generated)
def train_pipeline(config: TrainConfig) -> Result[TrainingState, TrainingError]:
    """
    Complete training pipeline.
    
    Steps:
    1. Validate configuration
    2. Load training data
    3. Initialize model
    4. Train model
    5. Save checkpoint
    
    Returns:
        Success(TrainingState): Final training state if all succeeds
        Failure(TrainingError): First error encountered
    """
    return (
        validate_config(config)
        .bind(lambda cfg: load_data(cfg).map(lambda data: (cfg, data)))
        .bind(lambda t: initialize_model(t[1]).map(lambda w: (t[0], t[1], w)))
        .bind(lambda t: train_model(t[0], t[1], t[2]))
        .bind(lambda state: save_checkpoint(config, state))
    )

# Usage (auto-generated)
config = TrainConfig(
    batch_size=32,
    learning_rate=0.001,
    num_epochs=10,
    checkpoint_dir='./checkpoints'
)

result = train_pipeline(config)

match result:
    case Success(state):
        print(f"Training complete!")
        print(f"Final loss: {state.loss:.4f}")
        print(f"Saved checkpoint at epoch {state.epoch}")
    case Failure(error):
        print(f"Training failed ({error._tag}): {error.message}")
```

---

## Key Patterns Summary

### The Pattern is Always the Same

**Python:**
```python
result = (
    step1(input)
    .bind(step2)
    .bind(step3)
    .map(step4)
)
```

**TypeScript:**
```typescript
const result = pipe(
  step1(input),
  TE.flatMap(step2),
  TE.flatMap(step3),
  TE.map(step4)
)
```

### Quick Reference Card for Developers

```
┌─────────────────────────────────────────────────┐
│  PYTHON              │  TYPESCRIPT             │
├──────────────────────┼─────────────────────────┤
│  .bind(func)         │  TE.flatMap(func)       │  ← Can fail
│  .map(func)          │  TE.map(func)           │  ← Can't fail
│  Success(value)      │  TE.right(value)        │  ← Success
│  Failure(error)      │  TE.left(error)         │  ← Error
│  match result:       │  if (result._tag...)    │  ← Check result
└─────────────────────────────────────────────────┘

MENTAL MODEL: Think of a factory assembly line
- Each step either succeeds or fails
- If any fails, whole chain stops
- If all succeed, you get final product
```

---

## What Claude Automatically Generates

When you describe a task, Claude generates:

1. ✅ **Types** - All data structures and errors
2. ✅ **Individual functions** - Each step of the pipeline
3. ✅ **Composed chain** - Complete pipeline
4. ✅ **Error handling** - Proper Result/Either types
5. ✅ **Usage example** - How to call and pattern match
6. ✅ **Documentation** - What each step does

**Same pattern, every time, both languages.**

---

## For Team Leads

### Onboarding New Developers

1. **Show them the pattern:**
   - "It's like an assembly line"
   - "Each function does one thing"
   - "Chain them together with `.bind()` or `flatMap()`"

2. **Give them the quick reference card**

3. **Show them 2-3 examples**

4. **They're productive in an hour**

### Code Reviews

**Check:**
- [ ] Each function does one thing
- [ ] Functions return `Result`/`Either`
- [ ] Chain uses `.bind()`/`flatMap()` for fallible operations
- [ ] Chain uses `.map()` for pure transformations
- [ ] Final result is pattern matched
- [ ] Error types are specific

### Benefits You Get

✅ **Consistency** - All code follows same pattern
✅ **Maintainability** - Easy to understand and modify
✅ **Error handling** - Never forget to handle errors
✅ **Testability** - Each function tested independently
✅ **Composability** - Build complex from simple
✅ **Type safety** - Compiler catches mistakes

---

*Developers don't need to understand category theory. They just need to recognize the pattern and follow it. Claude generates it automatically, and it's the same across all your projects.*
