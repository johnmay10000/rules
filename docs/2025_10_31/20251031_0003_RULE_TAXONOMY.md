# Global Rule Taxonomy

**Created**: 2025-10-31 10:00  
**Phase**: Phase 1 - Foundation  
**Purpose**: Categorize all rules from existing documents into hierarchical taxonomy

---

## Analysis Sources

**Documents Analyzed**:
1. `FP_GUIDE_README.md` - Overview of FP guides and universal patterns
2. `how-to-use-fp-style-guides.md` - Integration methods and setup patterns
3. `code-style.mdc` - Mandatory code style rules (project-specific but generalizable)
4. `CLAUDE.md` - Git workflow, documentation, and project management rules

---

## Taxonomy Structure

### Tier 1: MANDATORY Universal Rules
**Applies to**: ALL projects, ALL tech stacks  
**Priority**: üî• CRITICAL  
**Enforcement**: Non-negotiable

### Tier 2: RECOMMENDED Universal Patterns
**Applies to**: ALL projects, but can be adapted  
**Priority**: ‚≠ê STRONG RECOMMENDATION  
**Enforcement**: Follow unless good reason not to

### Tier 3: Language-Specific Rules
**Applies to**: Specific language or platform  
**Priority**: üìù REQUIRED for that stack  
**Enforcement**: Mandatory when using that tech

---

## TIER 1: MANDATORY UNIVERSAL RULES

### 1.1 Git Workflow (MANDATORY)

**Source**: `CLAUDE.md`, `code-style.mdc`, `.cursorrules`

#### Git Checkpoints (CRITICAL)
- ‚úÖ **Every 30-60 minutes** maximum time between commits
- ‚úÖ **After fixing any bug** (no matter how small)
- ‚úÖ **After implementing feature** or improvement
- ‚úÖ **After documentation updates**
- ‚úÖ **Before starting refactoring**
- ‚úÖ **At end of work session** (daily checkpoint)
- ‚úÖ **After completing phase** in multi-phase work

**Rationale**: Prevents work loss, clear history, easy context preservation

#### Commit Message Format (MANDATORY)
```
Brief summary (50-72 chars)

- Bullet points describing changes
- Why the change was made
- Expected impact

Status: <current state>

ü§ñ Generated with Cursor
Co-Authored-By: Claude <noreply@anthropic.com>
```

**Required Elements**:
- Brief summary line
- Detailed description
- Rationale
- Files affected
- Context/decisions
- Status indicator

---

### 1.2 Documentation Structure (MANDATORY)

**Source**: `CLAUDE.md`, `.cursorrules`

#### Three-Tier Documentation Hierarchy

**Tier 1: Strategic** (`ARCHITECTURE_PLAN.md`)
- Location: Project root
- Purpose: High-level architecture, major components
- Updated: Rarely (major changes only)
- Cross-references: Links to Tier 2 plans

**Tier 2: Tactical** (`docs/plans/*.md`)
- Location: `docs/plans/`
- Purpose: Feature/area plans with paired TODO lists
- Format: `FEATURE_NAME_PLAN.md` + `FEATURE_NAME_TODO.md`
- Updated: Regularly as features progress
- Must include: Phases, time estimates, checklist, update history

**Tier 3: Execution** (`docs/YYYY_MM_DD/*.md`)
- Location: `docs/2025_10_31/` (dated folders)
- Purpose: Daily work, decisions, summaries
- Format: `YYYYMMDD_HHMM_DESCRIPTIVE_NAME.md` (NO separators)
- Updated: Daily/frequently
- Examples: `20251031_1000_FEATURE_IMPLEMENTATION.md`

**Rationale**: Clear separation of concerns, easy navigation, context preservation

---

#### Documentation Filename Format (MANDATORY)

**Daily Work Documents**:
```
YYYYMMDD_HHMM_DESCRIPTIVE_NAME.md
```

**Examples**:
- ‚úÖ `20251031_0900_CURSOR_MD_IMPLEMENTATION.md`
- ‚úÖ `20251031_1530_BUG_FIX_VALIDATION.md`
- ‚ùå `2025_10_31_SUMMARY.md` (has separators)
- ‚ùå `SUMMARY.md` (missing timestamp)

**Plan Documents** (in `docs/plans/`):
```
FEATURE_NAME_PLAN.md
FEATURE_NAME_TODO.md
```

**No timestamps** for plans (living documents)

**Rationale**: Chronological sorting, exact creation time visible, no collisions

---

#### Plan Documents (MANDATORY for Complex Work)

**When Required**:
- New features (3+ hours)
- Architectural changes
- Bug fixes with investigation
- System integrations
- Multi-step refactoring

**Required Structure**:
```markdown
# Feature Name Plan

**Status**: ‚è≥ IN PROGRESS / ‚úÖ COMPLETE
**Last Updated**: YYYY-MM-DD HH:MM

## Overview
What needs to be done and why

## Phases
- [ ] Phase 1: Description (time estimate)
- [ ] Phase 2: Description (time estimate)

## Implementation Details
- Code locations
- ADT structures
- Key functions

## Success Criteria
How to verify completion

## Update History
### YYYY-MM-DD HH:MM
- Completed Phase 1
- Started Phase 2
```

**Paired TODO List**:
```markdown
# Feature Name TODO

**Plan Reference**: FEATURE_NAME_PLAN.md
**Progress**: X/Y tasks (Z%)

## Phase 1
- [x] Task 1 (Estimated: 1h, Actual: 1.2h)
- [ ] Task 2 (Estimated: 2h, Actual: -)
```

**Cursor Responsibility**: Automatically update TODO lists as work progresses

---

### 1.3 Testing Requirements (MANDATORY)

**Source**: `code-style.mdc`, `CLAUDE.md`, docs from planning phase

#### Comprehensive Testing Rule

**Core Rule**: ALL production code MUST have comprehensive tests that pass before committing

**"Comprehensive" Defined**:
1. ‚úÖ **Happy path** - Normal expected behavior
2. ‚úÖ **Error cases** - All failure modes explicitly tested
3. ‚úÖ **Edge cases** - Boundary conditions, empty inputs, large inputs
4. ‚úÖ **Regression tests** - Past bugs stay fixed

**Minimum Coverage**:
- Functions with business logic: **3+ tests**
- Business logic modules: **80%+ coverage**
- Utility functions: **2+ tests** (happy path + error)
- Integration points: **100% error paths**

**Special Requirements**:
- FP migration: Old and new code must have equivalent test coverage
- No test skipping without documented reason
- All tests must pass before commit (no broken tests)

**Language-Specific Tools** (see Tier 3 for details):
- Python: `pytest`, `uv run pytest`
- TypeScript: `jest` or `vitest`
- Swift: XCTest
- Kotlin: JUnit + Kotest

---

### 1.4 File Size Limits (MANDATORY)

**Source**: `code-style.mdc`, `CLAUDE.md`

#### File Length Rule

**Python**: 250-300 lines maximum per file  
**TypeScript**: 250-300 lines maximum per file  
**Swift**: 250-300 lines maximum per file  
**Kotlin**: 250-300 lines maximum per file

**Universal Rule**: **250-300 lines maximum**

**How to Comply**:
1. Split into multiple files if necessary
2. Create folder for each functional module
3. Organize by feature or responsibility
4. **Do NOT modify functionality** to reduce file size

**Rationale**: Maintainability, readability, focused modules, easier code review

**Acceptable Exceptions**:
- Generated code (must be marked as generated)
- Configuration files (if unavoidable)
- Single complex algorithm that can't be split

---

## TIER 2: RECOMMENDED UNIVERSAL PATTERNS

### 2.1 Functional Programming Principles (STRONGLY RECOMMENDED)

**Source**: All FP guides, `code-style.mdc`

**User Decision**: Mandatory for new code, incremental migration for old code

#### Core FP Principles

**1. Pure Functions**
- No side effects
- Same input ‚Üí same output
- Testable in isolation
- Example: `def add(a: int, b: int) -> int: return a + b`

**2. Immutable Data Structures**
- No mutations after creation
- Use `@dataclass(frozen=True)` (Python)
- Use `readonly` (TypeScript)
- Use `val` / `let` (Kotlin/Swift)

**3. Algebraic Data Types (ADTs)**
- Type-safe data modeling
- Pattern matching for control flow
- Exhaustive case handling
- Example: `Success | Failure`

**4. Result/Either Types for Error Handling**
- No naked exceptions
- Explicit error types
- Railway-oriented programming
- Example: `Result[T, E]` instead of `try/catch`

**5. Function Composition**
- Build complex from simple
- `pipe`, `flow`, `compose`
- Declarative pipelines
- Example: `pipe(validate, transform, save)`

**6. Pattern Matching**
- Use `match/case` extensively (Python)
- Use discriminated unions (TypeScript)
- Use `when` (Kotlin), `switch` (Swift)
- No `isinstance()` checks

**7. No Defaults/Fallbacks**
- Signal failures explicitly
- Never use default values for errors
- Record failures, don't hide them
- No synthetic/dummy data

---

#### Universal FP Pattern (Cross-Language)

**Mental Model**: "Factory assembly line"
- Each station = one function
- Each function does one thing
- If any fails, line stops
- If all succeed, get final product

**Python**:
```python
result = (
    fetch_data(id)
    .bind(validate)
    .bind(transform)
    .map(format)
)
```

**TypeScript**:
```typescript
const result = pipe(
  fetchData(id),
  TE.flatMap(validate),
  TE.flatMap(transform),
  TE.map(format)
)
```

**Swift**:
```swift
let result = fetchData(id)
    .flatMap(validate)
    .flatMap(transform)
    .map(format)
```

**Kotlin**:
```kotlin
val result = fetchData(id)
    .flatMap { validate(it) }
    .flatMap { transform(it) }
    .map { format(it) }
```

**Same pattern across all languages!**

---

### 2.2 Code Organization Patterns (RECOMMENDED)

**Source**: `how-to-use-fp-style-guides.md`, `CLAUDE.md`

#### Layered Architecture

**Layer 1: Pure Core** (Domain Logic)
- Pure functions
- No IO
- Business rules
- Data transformations

**Layer 2: Result/Either Layer** (Error Handling)
- Wrap operations in Result types
- Explicit error handling
- Pattern matching

**Layer 3: IO Layer** (Side Effects)
- Database operations
- API calls
- File system access
- External services

**Layer 4: Application Entry Points**
- HTTP handlers
- CLI interfaces
- Event handlers
- Orchestration

**Rationale**: Clear separation, testability, maintainability

---

#### Project Structure Template

**Backend**:
```
src/
‚îú‚îÄ‚îÄ types/              # ADTs, domain types, errors
‚îú‚îÄ‚îÄ domain/             # Pure business logic
‚îú‚îÄ‚îÄ services/           # IO operations with Result types
‚îú‚îÄ‚îÄ api/                # HTTP handlers
‚îî‚îÄ‚îÄ utils/              # Utility functions
```

**Frontend**:
```
src/
‚îú‚îÄ‚îÄ types/              # ADTs, domain types
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ fp/            # FP utilities (Result, pipe, etc.)
‚îÇ   ‚îú‚îÄ‚îÄ api/           # API clients with TaskEither
‚îÇ   ‚îî‚îÄ‚îÄ db/            # Database operations
‚îú‚îÄ‚îÄ components/         # UI components
‚îî‚îÄ‚îÄ app/                # Next.js routes
```

---

### 2.3 Type Safety Patterns (RECOMMENDED)

**Source**: All FP guides

#### Type-Driven Development

**1. Define Types First**
- Domain types
- Error types
- State types
- Input/output types

**2. Write Function Signatures**
- Clear input/output
- Explicit error types
- Generic where appropriate

**3. Implement with Compiler Guidance**
- Let types guide implementation
- Compiler catches mistakes
- Refactoring is safe

**Example**:
```python
# 1. Define types
@dataclass(frozen=True)
class User:
    id: str
    email: str
    age: int

@dataclass(frozen=True)
class ValidationError:
    field: str
    message: str

# 2. Write signature
def validate_user(data: dict) -> Result[User, ValidationError]:
    ...

# 3. Implement
def validate_user(data: dict) -> Result[User, ValidationError]:
    if 'email' not in data:
        return Failure(ValidationError('email', 'Required'))
    # ...
    return Success(User(...))
```

---

## TIER 3: LANGUAGE-SPECIFIC RULES

### 3.1 Python-Specific Rules

**Source**: `python-fp-style-guide.md`, `code-style.mdc`

#### Required Libraries
- `returns` - Result/Either types, monadic composition
- `toolz` - Functional utilities
- `mypy` - Type checking
- `pytest` - Testing
- `polars` - Data processing (NEVER pandas)

#### Tool Usage (MANDATORY for Python)
- ‚úÖ `uv` for package management (not pip)
- ‚úÖ `uv run python` to run code
- ‚úÖ `uv run pytest` for tests
- ‚úÖ `ruff` for linting
- ‚úÖ `black` for formatting
- ‚úÖ `isort` for import sorting
- ‚úÖ `mypy` for type checking

#### Type Annotations
- ALL functions must have type annotations
- Use `-> Result[T, E]` for fallible operations
- Avoid `Any` type - create specific types
- Use `TypeVar` for generics

#### Pattern Matching
- Use `match/case` extensively (Python 3.10+)
- No `isinstance()` checks
- Exhaustive case handling

#### Data Structures
- Use `@dataclass(frozen=True)` for immutability
- Use `NamedTuple` for simple structures
- Pattern matching destructuring

---

### 3.2 TypeScript-Specific Rules

**Source**: `typescript-fp-style-guide.md`

#### Required Libraries
- `fp-ts` OR `Effect` (Effect recommended)
- `monocle-ts` - Optics/lenses (optional)
- `io-ts` - Runtime validation (optional)

#### TypeScript Config (MANDATORY)
```json
{
  "compilerOptions": {
    "strict": true,
    "strictNullChecks": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitAny": true,
    "exactOptionalPropertyTypes": true
  }
}
```

#### ESLint Rules (RECOMMENDED)
```json
{
  "plugins": ["functional"],
  "rules": {
    "functional/immutable-data": "error",
    "functional/no-let": "warn",
    "functional/no-loop-statements": "warn"
  }
}
```

#### Type Safety
- Use `readonly` for all data
- Use discriminated unions for ADTs
- Explicit `TaskEither<E, A>` or `Effect<A, E>`
- No `any` type

---

### 3.3 Swift-Specific Rules

**Source**: `swift-fp-style-guide.md`

#### Built-in Features
- `Result<Success, Failure>` type
- Pattern matching with `switch`
- Value types (structs) over reference types
- Protocol-oriented programming + FP

#### Optional Libraries
- `Bow` - Comprehensive FP library
- `Composable Architecture` - State management

#### Immutability
- Prefer `let` over `var`
- Use `struct` for value semantics
- Immutable `Array`, `Dictionary` by default

---

### 3.4 Kotlin-Specific Rules

**Source**: `kotlin-fp-style-guide.md`

#### Required Libraries
- `Arrow` - Core FP library
- `kotlinx-coroutines` - Async operations

#### Type Safety
- Use `sealed class` for ADTs
- Use `data class` for immutable data
- Use `Either<E, A>` for error handling
- Use `when` for pattern matching

#### Immutability
- Prefer `val` over `var`
- Use `data class` with `val` properties
- Use immutable collections

---

### 3.5 Platform-Specific Rules

#### GCP (Google Cloud Functions)

**Source**: `CLAUDE.md`, `code-style.mdc`

**Critical Rules**:
1. No `__init__.py` files
2. Use direct imports for root modules
3. Use `folder.module` pattern for subfolders
4. Never use package paths
5. Tests must use `sys.path.append()`

**Structure**:
```
function_name/
‚îú‚îÄ‚îÄ main.py                 # @functions_framework decorator
‚îú‚îÄ‚îÄ function_orchestrator.py
‚îú‚îÄ‚îÄ types.py
‚îú‚îÄ‚îÄ subfolder/
‚îÇ   ‚îî‚îÄ‚îÄ module.py
‚îî‚îÄ‚îÄ requirements.txt
```

**Imports**:
```python
# Root level
from types import Result
from function_orchestrator import orchestrate

# Subfolders
from subfolder.module import function

# Tests
sys.path.insert(0, str(function_dir))
```

#### AWS (Lambda)
- TBD (will be in `CURSOR_CLOUD_AWS.md`)

---

## Rule Conflicts and Resolutions

### Identified Conflicts

**1. Polars vs Pandas**
- `code-style.mdc`: "Always use Polars, never use Pandas"
- **Resolution**: MANDATORY Polars for new code, document exceptions for legacy

**2. File Size Exceptions**
- General: 250-300 lines strict
- `CLAUDE.md`: calibration_calculator.py at 339 lines marked "acceptable"
- **Resolution**: 250-300 is target, 350 absolute maximum with justification

**3. Defaults/Fallbacks**
- `code-style.mdc`: "Never use defaults"
- Real-world: Some defaults are necessary (e.g., timeout values)
- **Resolution**: No defaults for business logic, explicit documentation for infrastructure defaults

---

## Cross-Cutting Concerns

### 1. Cursor Integration

**From all sources**:
- Use `.cursorrules` file in project root
- Reference global rules via `@filename` syntax
- Portable paths using `${CURSOR_RULES_PATH}` or `.cursor-rules/`
- Auto-detection for tech stack
- Smart templates for project setup

### 2. Automatic Code Generation

**Pattern**: User describes task ‚Üí Cursor generates pipeline

**Key Insight**: Same pattern across all languages!
- Python: `.bind()`, `.map()`
- TypeScript: `TE.flatMap()`, `TE.map()`
- Swift: `.flatMap()`, `.map()`
- Kotlin: `.flatMap {}`, `.map {}`

### 3. Team Adoption

**Mental Model**: "Factory assembly line"
- No category theory required
- Follow the pattern
- Compiler catches errors
- Easy to maintain

---

## Summary Statistics

### Rules Extracted

**Tier 1 (Mandatory Universal)**: 20 rules
- Git workflow: 7 rules
- Documentation: 8 rules
- Testing: 3 rules
- File size: 2 rules

**Tier 2 (Recommended Universal)**: 15 patterns
- FP principles: 7 core principles
- Code organization: 4 patterns
- Type safety: 4 patterns

**Tier 3 (Language-Specific)**: 35+ rules
- Python: 10 rules
- TypeScript: 8 rules
- Swift: 5 rules
- Kotlin: 5 rules
- GCP: 7 rules
- AWS: TBD

**Total**: 70+ rules and patterns identified

---

## Next Steps

### For CURSOR.md Creation

**Include from Tier 1**:
- All git workflow rules
- All documentation structure
- All testing requirements
- File size limits

**Include from Tier 2**:
- Core FP principles (7)
- Layered architecture pattern
- Type-driven development

**Defer to Language Guides**:
- Specific libraries
- Tool configurations
- Language-specific patterns

**Defer to Platform Guides**:
- GCP import rules
- AWS deployment patterns

---

## Taxonomy Categories

### By Enforcement Level
1. **MANDATORY** - Must follow, no exceptions
2. **STRONGLY RECOMMENDED** - Follow unless good reason
3. **RECOMMENDED** - Good practice, adapt as needed
4. **OPTIONAL** - Nice to have

### By Scope
1. **Universal** - All projects, all stacks
2. **Language** - Specific language
3. **Platform** - Specific platform (GCP, AWS)
4. **Project** - Project-specific (in `.cursorrules`)

### By Category
1. **Workflow** - Git, documentation, planning
2. **Code Style** - File size, structure, organization
3. **Functional Programming** - Principles, patterns
4. **Type Safety** - Types, ADTs, validation
5. **Testing** - Coverage, requirements
6. **Integration** - Cursor setup, auto-detection

---

**Taxonomy Complete**: Ready to create CURSOR.md with clear rule hierarchy

**Total Analysis Time**: 30 minutes  
**Documents Analyzed**: 4  
**Rules Categorized**: 70+  
**Conflicts Resolved**: 3

