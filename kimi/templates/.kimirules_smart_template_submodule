# Smart .kimirules Template (Git Submodule Version)
# 
# SELF-CONTAINED: No machine setup required
# SETUP: Run `git submodule add <repo-url> .kimi-rules` once per project
# Then: `ln -s .kimi-rules/kimi/KIMI.md .kimirules`
#
# This template uses relative paths and works on any machine.
# Auto-detects project type and loads appropriate rules.
# Copy to your project root as .kimirules

---

## ‚ö†Ô∏è SETUP CHECK

# If you see errors about files not found:
# 1. Ensure .kimi-rules submodule exists
# 2. Run: ls .kimi-rules/kimi/KIMI.md
# 3. Verify symlink: ls -la .kimirules (should point to .kimi-rules/kimi/KIMI.md)

---

## üåç GLOBAL RULES (All Projects)

# Core mandatory rules - git checkpoints, FP principles, documentation
@.kimi-rules/kimi/KIMI.md

# Workflow guide - git workflow, documentation hierarchy, TODO lists, SetTodoList tool
@.kimi-rules/kimi/KIMI_WORKFLOW_GUIDE.md

# FP principles deep dive - ADTs, Result types, monadic composition
@.kimi-rules/kimi/KIMI_FP_PRINCIPLES.md

# Data structure patterns - Foldable/Traversable across languages
@.kimi-rules/kimi/DATA_STRUCTURE_PATTERNS.md

# File locations guide - portable setup, environment variables
@.kimi-rules/kimi/FILE_LOCATIONS_USER_GUIDE.md

# Naming conventions - YYYYMMDD_NNNN format, auto-numbering
@.kimi-rules/kimi/NAMING_CONVENTION.md

---

## üìù LANGUAGE-SPECIFIC RULES (Auto-Detected)

### Python Projects
# Detected if: requirements.txt, pyproject.toml, setup.py, or *.py files exist
# 
# Includes: returns, toolz, ADTs, Result types, pytest, mypy
# FP libraries: returns (Result/Maybe), toolz (functional utilities)
# Style: File size 250-300 lines, immutable data, pattern matching
# Kimi patterns: Parallel validation with Task tool, subagent for complex pipelines
#
# Uncomment if this is a Python project:
# @.kimi-rules/kimi/python-fp-style-guide.md

### TypeScript Projects
# Detected if: package.json with "typescript" dependency exists
# 
# Includes: fp-ts/Effect, TaskEither, Option, immutable types
# FP libraries: fp-ts, Effect (ZIO-inspired), ts-pattern
# Style: readonly, as const, never mutate, railway-oriented programming
# Kimi patterns: Parallel type-checking, subagent for effect validation
#
# Uncomment if this is a TypeScript project:
# @.kimi-rules/kimi/typescript-fp-style-guide.md

### Rust Projects
# Detected if: Cargo.toml or *.rs files exist
# 
# Includes: Result, Option, Iterators, ownership, zero-cost abstractions
# FP libraries: Native (no external deps needed for core FP)
# Style: Immutable by default, explicit error types, no unwrap() in prod
# Kimi patterns: Parallel compilation checks, subagent for borrow-checking validation
#
# Uncomment if this is a Rust project:
# @.kimi-rules/kimi/rust-fp-style-guide.md

### Swift Projects
# Detected if: Package.swift, *.xcodeproj, or *.swift files exist
# 
# Includes: Result, Optional, value types, protocols
# FP libraries: Swift Composable Architecture (TCA), Overture, Tagged
# Style: let over var, structs over classes, explicit Result types
# Kimi patterns: Parallel view validation, subagent for TCA reducer verification
#
# Uncomment if this is a Swift project:
# @.kimi-rules/kimi/swift-fp-style-guide.md

### Kotlin Projects
# Detected if: build.gradle(.kts), pom.xml, or *.kt files exist
# 
# Includes: Arrow (Either, Option, Validated), immutable collections
# FP libraries: Arrow (core, fx, optics), Kotlinx Coroutines
# Style: val over var, data classes, explicit Either types
# Kimi patterns: Parallel coroutine validation, subagent for Arrow pattern checks
#
# Uncomment if this is a Kotlin project (including Android):
# @.kimi-rules/kimi/kotlin-fp-style-guide.md

### Haskell Projects
# Detected if: *.cabal, stack.yaml, or *.hs files exist
# 
# Includes: Native FP (pure functions, monads, typeclasses)
# FP libraries: Built-in (Functor, Applicative, Monad, etc.)
# Style: Pure functions, explicit types, pattern matching
# Kimi patterns: Parallel type-check across modules, subagent for law verification
#
# Uncomment if this is a Haskell project:
# @.kimi-rules/kimi/haskell-fp-style-guide.md

---

## ‚òÅÔ∏è PLATFORM-SPECIFIC RULES (Auto-Detected)

### AWS Projects
# Detected if: template.yaml, serverless.yml, or .aws/ directory exists
# 
# Includes: Lambda, Step Functions, DynamoDB, EventBridge, S3 patterns
# FP patterns: Railway-oriented handlers, event sourcing, immutable snapshots
# Kimi patterns: Parallel deployment validation, multi-region verification
#
# Uncomment if this uses AWS services:
# @.kimi-rules/kimi/aws-fp-style-guide.md

### GCP Projects
# Detected if: app.yaml, cloudbuild.yaml, or firebase.json exists
# 
# Includes: Cloud Functions, Cloud Run, Firestore, Pub/Sub, Eventarc
# FP patterns: Pure handler factories, event sourcing, circuit breakers
# Kimi patterns: Multi-environment validation, circuit breaker verification
#
# Uncomment if this uses Google Cloud Platform:
# @.kimi-rules/kimi/gcp-fp-style-guide.md

---

## üèóÔ∏è PROJECT-SPECIFIC CUSTOMIZATIONS

# Add your project-specific rules here.
# These override or extend the global patterns above.
# Keep customizations minimal and focused.

# Example: Python ML project
# Note: For Python ML/MLX projects, extend python-fp-style-guide.md
# Note: For MLX specifically, see additional notes below

# Example: TypeScript Next.js + Supabase project
# - Use TaskEither for all data fetching
# - Use Effect for complex business logic
# - No try/catch blocks (use railway error handling)
# - Prefer Zod for runtime validation schemas
# - Use TanQuery with fp-ts/Either for caching

# Example: Rust CLI project
# - Use anyhow for application-level errors
# - Use thiserror for library errors
# - No unwrap() in production code
# - Prefer Iterator combinators over loops
# - Use clap for type-safe CLI parsing

# Example: Swift iOS project
# - Use TCA (Swift Composable Architecture)
# - No @StateObject in SwiftUI (use Environment)
# - Prefer value types (struct over class)
# - Use Tagged for type-safe identifiers
# - Use SwiftFormat and SwiftLint

# Example: Kotlin Android/Ktor project
# - Use Arrow Either for all operations
# - Use Arrow Optics for nested updates
# - No nullable types (use Option instead)
# - Use Kotlinx Serialization for JSON
# - Arrow Fx for structured coroutines

# Example: Haskell web service
# - Use Servant for type-safe APIs
# - Use Polysemy/MTL for effects
# - Use Lens for record updates
# - Property tests with QuickCheck/Hedgehog
# - Use GHC extensions: DerivingVia, DerivingStrategies

---

## üöÄ KIMI-SPECIFIC WORKFLOW

When working in this project, Kimi will:

1. **Read .kimirules** to load appropriate global and language-specific rules
2. **Auto-detect** project type and platform based on files present
3. **Use parallel tool calls** to validate multiple files/functions simultaneously
4. **Spawn subagents** for complex validations (type checking, law verification)
5. **Follow mandatory patterns**:
   - Git checkpoint every 30-60 minutes
   - Documentation naming: YYYYMMDD_NNNN_DESCRIPTIVE_NAME.md
   - SetTodoList tool for task tracking (NOT manual TODO files)
   - Three-tier documentation hierarchy
   - Railway-oriented error handling (no exceptions)
   - Immutable data structures

---

## üìã QUICK START CHECKLIST

After copying this template to your project:

- [ ] Add rules submodule: `git submodule add <repo-url> .kimi-rules`
- [ ] Create symlink: `ln -s .kimi-rules/kimi/KIMI.md .kimirules`
- [ ] Uncomment appropriate language-specific guide(s)
- [ ] Uncomment platform-specific guide if using cloud services
- [ ] Add project-specific customizations below
- [ ] Test: `kimi read-file .kimirules` (should show content)
- [ ] Create first daily work document
- [ ] Initialize SetTodoList with project tasks

---

## ‚öôÔ∏è TROUBLESHOOTING

### ".kimi-rules/kimi/KIMI.md not found"
**Solution**: 
```bash
# Check submodule exists
ls -la .kimi-rules/  # Should show files, not empty

# If empty, initialize submodules:
git submodule update --init --recursive
```

### "Symlink broken or not pointing correctly"
**Solution**:
```bash
# Verify symlink
ls -la .kimirules  # Should show: .kimirules -> .kimi-rules/kimi/KIMI.md

# If broken or pointing elsewhere, recreate:
rm .kimirules
ln -s .kimi-rules/kimi/KIMI.md .kimirules
```

### "Kimi not loading rules"
**Solution**:
```bash
# Verify symlink works correctly
cat .kimirules  # Should show content (not "No such file")

# If file exists but contents wrong, recreate symlink
```

### "Wrong language guide loaded"
**Solution**:
```bash
# Check current uncommented rules
grep -E "^@\.kimi-rules" .kimirules

# Uncomment correct language(s) by removing "#" from beginning of line
```

---

## üë• TEAM SETUP

When sharing this project with your team:

1. **Each developer runs once**:
   ```bash
   git submodule update --init --recursive
   ```

2. **Verify on each machine**:
   ```bash
   cat .kimirules  # Should show content
   ```

3. **Works identically** on macOS, Linux, Windows (WSL)

4. **All team members** use same rule version automatically

---

## üìñ FURTHER DOCUMENTATION

- **Full Global Rules**: .kimi-rules/kimi/KIMI.md
- **Setup Instructions**: .kimi-rules/kimi/SETUP_GUIDE.md
- **Workflow Guide**: .kimi-rules/kimi/KIMI_WORKFLOW_GUIDE.md
- **FP Principles**: .kimi-rules/kimi/KIMI_FP_PRINCIPLES.md

---

## üéØ PROJECT-SPECIFIC NOTES

# Add any project-specific notes or reminders here.
# These are visible to Kimi as additional context.

# Example notes:
# - This project uses Effect rather than fp-ts
# - All API responses must be wrapped in TaskEither
# - No exceptions allowed (use Result types only)
# - Immutability: use readonly and as const
# - Testing: 100% coverage required before commit

---

## üîß ADVANCED: Submodule Updates

To update to latest rules version:

```bash
# Pull latest rules
cd .kimi-rules
git pull origin main
cd ..

# Commit the submodule update
git add .kimi-rules
git commit -m "Update rules submodule"
```

---

**Template Version**: 1.0.0  
**Last Updated**: 2025-11-14  
**Maintained By**: Kimi CLI Global Rules System
